# LazyA Language Specification v0.1

## Overview

LazyA is a general-purpose, AI-native programming language with hybrid typing and semantic operators.

## Syntax Basics

### Comments
```lazy
// Single line comment

/* 
   Multi-line comment
   Supports nested /* comments */
*/
```

### Variables & Types

#### Type System
LazyA uses **hybrid typing**:
- Weak typing for AI operations (semantic flexibility)
- Strong typing for critical operations (safety)
- Type inference where possible

```lazy
// Type inference
name = "Alan"           // inferred as string
age = 23                // inferred as int
score = 95.5            // inferred as float

// Explicit typing
name: string = "Alan"
age: int = 23
is_student: bool = true

// AI-flexible types
concept: any = "happiness"  // can be compared semantically
```

### Functions

#### Standard Functions
```lazy
func greet(name: string) -> string {
    return "Hello, " + name
}

// Type inference for return type
func add(a: int, b: int) {
    return a + b  // returns int
}

// No return value
func log_message(msg: string) {
    print(msg)
}
```

#### Context Functions (AI-Generated)
```lazy
@context
func calculate_sentiment(text: string) -> float {
    """
    Analyzes the sentiment of the given text.
    Returns a value between -1.0 (very negative) and 1.0 (very positive).
    Uses natural language processing techniques.
    """
}
// Implementation is generated by AI based on the docstring
```

### Operators

#### Standard Operators
```lazy
// Arithmetic
+ - * / % **

// Comparison
== != < > <= >=

// Logical
&& || !

// Assignment
= += -= *= /=
```

#### AI-Native Operators

##### Semantic Similarity `~=`
Compares concepts using cosine similarity of embeddings.

```lazy
text = "estÃºpido"
if text ~= "insulto" {
    print("Insult detected")
}

// Threshold can be specified
if text ~= "insulto" threshold 0.8 {
    print("High confidence insult")
}
```

##### Semantic Implication `~>`
Checks if one concept implies another.

```lazy
if "perro" ~> "animal" {
    print("Correct implication")
}
```

### Control Flow

```lazy
// If-else
if condition {
    // statements
} else if other_condition {
    // statements
} else {
    // statements
}

// While loop
while count < 10 {
    print(count)
    count += 1
}

// For loop
for i in range(0, 10) {
    print(i)
}

// For-each
for item in items {
    print(item)
}
```

### Data Structures

#### Arrays
```lazy
numbers: [int] = [1, 2, 3, 4, 5]
names = ["Alice", "Bob", "Charlie"]  // type inferred

// Access
first = numbers[0]

// Methods
numbers.append(6)
length = numbers.length()
```

#### Dictionaries
```lazy
person = {
    "name": "Alan",
    "age": 23,
    "student": true
}

// Access
name = person["name"]
age = person.age  // dot notation also works
```

### AI Integration

#### LLM Calls
```lazy
// Local model
response = llm.complete(
    "Explain quantum entanglement",
    model="local/llama3"
)

// Cloud model
response = llm.complete(
    "Write a haiku about programming",
    model="cloud/gpt-4",
    temperature=0.7
)

// Structured generation
result = llm.generate(
    prompt="Extract entities from: " + text,
    format="json",
    schema={
        "entities": ["string"],
        "sentiment": "float"
    }
)
```

#### Embeddings
```lazy
// Get embedding vector
vec = embed("artificial intelligence")

// Calculate similarity manually
similarity = cosine_similarity(embed("AI"), embed("machine learning"))
```

### Module System

```lazy
// Import
import math
import ai.nlp

// Selective import
from collections import List, Dict

// Use
result = math.sqrt(16)
tokens = ai.nlp.tokenize("Hello world")
```

### Error Handling

```lazy
try {
    result = risky_operation()
} catch err {
    print("Error: " + err.message)
} finally {
    cleanup()
}
```

## Type System Details

### Primitive Types
- `int`: 64-bit signed integer
- `float`: 64-bit floating point
- `string`: UTF-8 string
- `bool`: true/false
- `any`: flexible type for AI operations

### Composite Types
- `[T]`: Array of type T
- `{K: V}`: Dictionary with key type K and value type V
- `(T1, T2, ...)`: Tuple

### Type Annotations
```lazy
// Optional types
name: string? = null

// Union types
value: int | string = 42

// Generic functions
func identity<T>(value: T) -> T {
    return value
}
```

## Compilation Modes

### Cold Start
```bash
lazya program.lazy --cold-start
```
- Generates all AI code
- Compiles everything
- Creates cache

### Warm Start (default)
```bash
lazya program.lazy
```
- Uses cached binaries
- Only regenerates changed code
- Fast execution

### No AI Mode
```bash
lazya program.lazy --no-ai
```
- Skips all AI generation
- Requires manual implementation of @context functions
- Fastest compilation

## Reserved Keywords

```
func return if else while for in
break continue true false null
import from export
try catch finally throw
@context @cached @inline
int float string bool any
```

## Naming Conventions

- **Variables/Functions**: snake_case
- **Types**: PascalCase
- **Constants**: UPPER_SNAKE_CASE
- **Private**: _leading_underscore (convention)

## Comments on Design

LazyA is designed to be **speculative** - it should read almost like pseudocode. The AI integration allows developers to focus on **what** they want to achieve, while the language figures out **how**.

The hybrid type system provides flexibility where needed (AI operations) while maintaining safety for critical code paths.
